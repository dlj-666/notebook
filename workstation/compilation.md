---
## cpu 从内存中读写数据
- 步骤：先用地址线确定数据所在的储存器地址,然后用控制线传输命令，最后用后通过数据线对该地址的数据进行操作
- cpu和内存见的数据线：
1. 地址总线,决定访问的内存地址，有多少根线就代表能传递多大的地址数，每根线状态有0,1，因此N根线就有2的N次方个可能，可以寻找2的N次方种内存单元
2. 数据总线,传输数据，根据线数决定传输的数据的量,16根线一次传输16位数，8根线一次传输8位数
- 内存地址空间
# 寄存器  //类型很多
## 通用寄存器
- 储存一般数据
## 几条汇编指令
1. mov ax, 19213: ax = 19213
2. add ax, bx: ax = ax + bx //注意：ax和bx位数应该相同
## 寻址
???[1]为啥要分为段地址和偏移地址，[2]为什么要用特定的公式计算物理地址
- 物理地址= 段地址*16 + 偏移地址  //由cpu内的地址加法器完成
==[1]:首先，cpu的位数的意思是cpu所能及时处理和储存的最大位数，即寄存器最大位数，而不是地址加法器的最大位数，而段地址和偏移地址都来源于不同寄存器,所以最大位数受到寄存器限制，[2]而这样特定的公式就是约定如何提升位数,公式实质:基础位置+偏移位置.==
- 形象的比喻：走到图书馆的距离是2811米，但你给小明的信的长度只够写三个字，不过你有两张纸，于是你就一张写200，一张写811，并约定最终距离=前一张*10+后一张。
## 段的概念
- 段寄存器中每一个字节分成一段, eg.段寄存器中1000H到1007H是一段，这一段物理地址有80H个
- 地址表示法:段地址:偏移地址 eg.2000H:002CH表示2002CH地址
//注意，内存是连续的，不过可以用段来管理
## debug调试
## 寄存器CS和IP,至关重要的两个寄存器
- CS: 代码段寄存器,基本地址
- IP：指令指针寄存器,偏移地址
- CS:IP指向的内容被当作指令执行
总结：16位cpu通过地址加法器输出20位地址
----------------------------------------------------------------------
???[3]为什么输出的一个地址能返回三个地址组成的指令呢[4]为什么是通过访问内存得到指令
有没有一种可能,CS和IP所合成的是一个指向数组的指针,总之，目前我所不知道的：
???[5]内存加法器是怎么运作的[6]IP是怎么做到执行指令后加3偏移到下一条指令所在的位置的
## 修改CS、IP的指令
- jmp
*用法*: 
1. jmp 段地址:偏移地址,表示把CS和IP改变成这些这些地址
2. jmp 某一合法寄存器，eg.jmp ax 等同于mov IP, ax

